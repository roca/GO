package application

import (
	"fmt"
	"grpc-go-server/internal/port"
	"math/rand"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type ResiliencyService struct {
	ExitChan chan bool
}

var StatusCodeMap = map[uint32]codes.Code{
	0: codes.OK,
	1: codes.Canceled,
	2: codes.Unknown,
	3: codes.InvalidArgument,
	4: codes.DeadlineExceeded,
	5: codes.NotFound,
	6: codes.AlreadyExists,
	7: codes.PermissionDenied,
	8: codes.ResourceExhausted,
	9: codes.FailedPrecondition,
}

func generateErrStatus(statusCode uint32) error {
	str := "Generated by server"

	if sc, ok := StatusCodeMap[statusCode]; ok && sc == codes.OK {
		return nil
	}

	if sc, ok := StatusCodeMap[statusCode]; ok {
		return status.New(sc, str).Err()
	}
	return status.New(codes.Internal, str).Err()
}

func (r *ResiliencyService) GetResiliency(req *port.ResiliencyRequest) (*port.ResiliencyResponse, error) {

	delay := delay(req.MaxDelaySecond, req.MinDelaySecond)

	randomIndex := rand.Intn(len(req.StatusCodes))
	pick := req.StatusCodes[randomIndex]
	str := fmt.Sprintf("The time now is %v, execution delayed for %v milliseconds", time.Now().Format("15:04:05.000000"), delay)

	return &port.ResiliencyResponse{
		StatusCode: pick,
		Response:   str,
		Error:      generateErrStatus(pick),
	}, generateErrStatus(pick)
}

func (r *ResiliencyService) GetResiliencyStream(req *port.ResiliencyRequest) (*port.ResiliencyResponse, error) {
	return r.GetResiliency(req)
}
func (r *ResiliencyService) SendResiliencyStream(reqs []*port.ResiliencyRequest) (*port.ResiliencyResponse, error) {
	resps := make([]*port.ResiliencyResponse, 0)
	for _, req := range reqs {
		resp, err := r.GetResiliency(req)
		if err != nil {
			return nil, err
		}
		resps = append(resps, resp)
	}
	return resps[len(resps)-1], nil
}
func (r *ResiliencyService) BidirectionalResiliencyStream(req *port.ResiliencyRequest) <-chan *port.ResiliencyResponse {
	ch := make(chan *port.ResiliencyResponse)
	go func() {
		resp, err := r.GetResiliency(req)
		if err != nil {
			ch <- &port.ResiliencyResponse{
				Response:   "",
				StatusCode: 0,
				Error:      err,
			}
			close(ch)
			return
		}
		ch <- resp
		close(ch)
	}()
	return ch
}

func delay(maxDelaySecond, minDelaySecond int32) int {
	n := rand.Intn(int(maxDelaySecond-minDelaySecond)+1) + int(minDelaySecond)
	duration := time.Duration(n) * time.Millisecond
	time.Sleep(duration)
	return n
}
