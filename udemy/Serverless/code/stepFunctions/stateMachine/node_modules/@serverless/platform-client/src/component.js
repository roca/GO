/*
 * SERVERLESS PLATFORM SDK: COMPONENT
 */

const path = require('path')
const fs = require('fs')
const { tmpdir } = require('os')
const axios = require('axios')
const utils = require('./utils')

/**
 * Create a new Component
 * @param {*} orgName
 * @param {*} componentName
 */
const create = (orgName = null, componentName = null) => {
  // Validate
  if (!orgName || !componentName) {
    throw new Error(`'orgName' and 'componentName' are required`)
  }

  // Component
  const component = {}
  component.orgUid = null
  component.orgName = orgName
  component.componentName = componentName
  component.version = '0.0.1'
  component.author = null
  component.description = null
  component.keywords = null
  component.repo = null
  component.readme = null
  component.license = 'MIT'
  component.main = './src'

  return component
}

/**
 * Validates and (re)formats the component properties
 */
const validateAndFormat = (rawComponent) => {
  // Copy input object, otherwise the inputter will have unintended data modifications
  const component = Object.assign({}, rawComponent)

  // Format Helper - If shortened properties are used, replace them with full properties
  if (component.org) {
    component.orgName = component.org
    delete component.org
  }
  if (component.name) {
    component.componentName = component.name
    delete component.name
  }

  // Ensure "dev" version uses correct syntax
  if (component.version === 'dev') {
    component.version = '0.0.0-dev'
  }

  if (!component.orgName) {
    throw new Error(`'orgName' is required`)
  }
  if (!component.author) {
    throw new Error(`'author' is required`)
  }
  if (!component.componentName || !component.version) {
    throw new Error(`'componentName' or 'name and 'version' or 'version' are required`)
  }
  if (!component.main) {
    throw new Error(`'main' is required`)
  }

  return component
}

/**
 * Fetches a Component definition from the Registry
 */
const getFromRegistry = async (sdk, componentName, componentVersion) => {
  let endpoint = `${sdk.getDomain('registry')}/component/${componentName}`
  if (componentVersion) {
    endpoint = `${endpoint}/${componentVersion}`
  }
  return await utils.request({
    accessKey: sdk.accessKey,
    endpoint,
    method: `GET`
  })
}

/**
 * Publish to the Registry
 */
const publish = async (sdk, component) => {
  // Validate
  component = validateAndFormat(component)

  // Pre-Publish gets a pre-signed URL for upload and a bucket key
  const preResponse = await utils.request({
    endpoint: `${sdk.getDomain('registry')}/prePublish`,
    accessKey: sdk.accessKey,
    method: 'POST',
    data: {
      component
    }
  })

  const componentUrl = preResponse.componentUrl
  const componentKey = preResponse.componentKey

  // Get Component path and temporary path for packaging
  const componentPackagePath = path.join(
    tmpdir(),
    `${Math.random()
      .toString(36)
      .substring(6)}.zip`
  )

  // Zip Component and the special "handler.js"
  const handler = {}
  handler.fileName = '_handler.js'
  handler.fileContent = `const { handler } = require('@serverless/core');module.exports.handler = handler;`

  await utils.zip(component.main, componentPackagePath, [], [], [handler])

  // Axios auto-adds headers that causes signature mismatch
  // So we remove them manually
  const request = axios.create()
  request.defaults.headers.common = {}
  request.defaults.headers.put = {}
  const file = fs.readFileSync(componentPackagePath)

  // Make sure axios handles large packages
  const config = {
    maxContentLength: Infinity,
    maxBodyLength: Infinity
  }

  // Upload
  try {
    await request.put(componentUrl, file, config)
  } catch (e) {
    throw e
  }

  // Post-Publish sends a bucket key to create a Component function from the source code
  return await utils.request({
    endpoint: `${sdk.getDomain('registry')}/postPublish`,
    accessKey: sdk.accessKey,
    method: 'POST',
    data: {
      orgName: component.orgName,
      componentKey
    }
  })
}

module.exports = {
  create,
  getFromRegistry,
  publish
}
