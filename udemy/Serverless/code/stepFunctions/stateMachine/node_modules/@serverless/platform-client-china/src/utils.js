/**
 * SERVERLESS PLATFORM CLIENT SDK: UTILS
 */

const https = require('https')
const urlUtils = require('url')
const traverse = require('traverse')
const minimatch = require('minimatch')
const {
  Login: TencentAuth,
  Others: TencentUtils,
  Cam: TencentCAM,
  Debug: TencentDebug
} = require('@serverless/utils-china')

const utils = {}

/**
 * Wait for a number of miliseconds
 * @param {*} wait
 */
const sleep = async (wait) => new Promise((resolve) => setTimeout(() => resolve(), wait))

/**
 * Make HTTP API requests, easily
 * @param {*} options.endpoint
 * @param {*} options.data
 * @param {*} options.accessKey
 * @param {*} options.method
 */
const request = async (options) => {
  const url = urlUtils.parse(options.endpoint)
  const requestOptions = {
    protocol: url.protocol,
    hostname: url.hostname,
    port: url.port,
    path: url.path,
    method: options.method || 'POST',
    headers: options.headers || {
      'Content-Type': 'application/json'
    }
  }

  if (options.accessKey) {
    requestOptions.headers['authorization'] = `Bearer ${options.accessKey}`
  }

  const request = () =>
    new Promise((resolve, reject) => {
      const req = https.request(requestOptions, (res) => {
        res.setEncoding('utf8')
        let rawData = ''
        res.on('data', (chunk) => {
          rawData += chunk
        })
        res.on('end', () => {
          if (!res.complete) {
            return reject(
              new Error('The connection was terminated while the message was still being sent.')
            )
          }
          if (!rawData && res.statusCode < 400) {
            return resolve()
          }
          try {
            const data = JSON.parse(rawData)
            if (res.statusCode >= 400) {
              const error = new Error(
                data.message ||
                  `${res.statusCode} error of ${requestOptions.method} ${options.endpoint}`
              )
              error.response = {
                status: res.statusCode,
                data
              }
              return reject(error)
            }
            return resolve(data)
          } catch (e) {
            const error = new Error(
              `Failed pass returning data of ${requestOptions.method} ${options.endpoint}`
            )
            error.response = {
              status: res.statusCode,
              data: rawData
            }
            return reject(error)
          }
        })
      })

      req.on('error', (e) => {
        reject(e)
      })

      if (options.data) {
        req.write(options.data)
      }
      req.end()
    })

  try {
    return await request()
  } catch (error) {
    // log the request so that we could debug that stubborn random publish error.
    if (error.response && error.response.status && error.response.data.message) {
      throw new Error(`${error.response.status} - ${error.response.data.message}`)
    }
    throw error
  }
}

/**
 * Resolves any variables that require resolving before the engine.
 * This currently supports only ${env}.  All others should be resolved within the deployment engine.
 * @param {*} inputs
 */
const resolveInputEnvVariables = (inputs) => {
  const regex = /\${(\w*:?[\w\d.-]+)}/g
  let variableResolved = false
  const resolvedInputs = traverse(inputs).forEach(function(value) {
    const matches = typeof value === 'string' ? value.match(regex) : null
    if (matches) {
      let newValue = value
      for (const match of matches) {
        // Search for ${env:}
        if (/\${env:(\w*[\w.-_]+)}/g.test(match)) {
          const referencedPropertyPath = match.substring(2, match.length - 1).split(':')
          newValue = process.env[referencedPropertyPath[1]]
          variableResolved = true
        }
      }
      this.update(newValue)
    }
  })
  if (variableResolved) {
    return resolveInputEnvVariables(resolvedInputs)
  }
  return resolvedInputs
}

// Add to utils object
utils.sleep = sleep
utils.request = request
utils.resolveInputEnvVariables = resolveInputEnvVariables

/**
 *
 * Only load these Utilies when in a Node.js Environment
 *
 */

if (typeof window === 'undefined') {
  const path = require('path')
  const fs = require('fs')
  const AdmZip = require('adm-zip')
  const { parseUrl } = require('url')
  const https = require('https')
  const HttpsProxyAgent = require('https-proxy-agent')

  const getAgent = () => {
    // Use HTTPS Proxy (Optional)
    const proxy =
      process.env.proxy ||
      process.env.HTTP_PROXY ||
      process.env.http_proxy ||
      process.env.HTTPS_PROXY ||
      process.env.https_proxy

    const agentOptions = {}
    if (proxy) {
      Object.assign(agentOptions, parseUrl(proxy))
    }

    const ca = process.env.ca || process.env.HTTPS_CA || process.env.https_ca

    let caCerts = []

    if (ca) {
      // Can be a single certificate or multiple, comma separated.
      const caArr = ca.split(',')
      // Replace the newline -- https://stackoverflow.com/questions/30400341
      caCerts = caCerts.concat(caArr.map((cert) => cert.replace(/\\n/g, '\n')))
    }

    const cafile = process.env.cafile || process.env.HTTPS_CAFILE || process.env.https_cafile

    if (cafile) {
      // Can be a single certificate file path or multiple paths, comma separated.
      const caPathArr = cafile.split(',')
      caCerts = caCerts.concat(caPathArr.map((cafilePath) => fs.readFileSync(cafilePath.trim())))
    }

    if (caCerts.length > 0) {
      Object.assign(agentOptions, {
        rejectUnauthorized: true,
        ca: caCerts
      })
    }

    if (proxy) {
      return new HttpsProxyAgent(agentOptions)
    } else if (agentOptions.ca) {
      return new https.Agent(agentOptions)
    }
    return undefined
  }

  /**
   * Get the size of a directory
   * @param {string} p path to directory
   */
  const getDirSize = async (p) => {
    const stat = fs.statSync(p)
    if (stat.isFile()) {
      return stat.size
    } else if (stat.isDirectory()) {
      const entries = fs.readdirSync(p)
      return Promise.all(entries.map((e) => getDirSize(path.join(p, e)))).then((e) =>
        e.reduce((a, c) => a + c, 0)
      )
    }
    return 0
    // can't take size of a stream/symlink/socket/etc
  }

  /**
   * Zip a file
   * @param {*} inputDirPath
   * @param {*} outputZipPath
   */
  const zip = async (
    inputDirPath = null,
    outputFilePath = null,
    include = [],
    exclude = [],
    includeContent = []
  ) => {
    let format = outputFilePath.split('.')
    format = format[format.length - 1].trim()

    if (!['zip', 'tar'].includes(format)) {
      throw new Error('Please provide a valid format. Either a "zip" or a "tar"')
    }

    const zipper = new AdmZip()

    zipper.addLocalFolder(inputDirPath, null, (path) => {
      for (const excludeItem of exclude) {
        if (minimatch(path, excludeItem, { nocase: true })) {
          return false
        }
      }
      return true
    })

    if (include && include.length) {
      include.forEach((filePath) => zipper.addLocalFile(path.resolve(filePath)))
    }

    if (includeContent && includeContent.length) {
      includeContent.forEach((content) =>
        zipper.addFile(
          content.fileName,
          Buffer.alloc(content.fileContent.length, content.fileContent)
        )
      )
    }

    zipper.writeZip(outputFilePath)

    return outputFilePath
  }

  /**
   * Unzip a zipped file
   * @param {*} zipPath
   */
  const unzip = async (inputZipPath, removeZip) => {
    const destPath = path.join(
      '/tmp',
      Math.random()
        .toString(36)
        .substring(6)
    )
    const unzipper = new AdmZip(inputZipPath)
    unzipper.extractAllTo(destPath, true)
    // Delete zip file to preserve space on AWS Lambda (it's limited to 250MB)
    if (removeZip) {
      fs.rmdirSync(inputZipPath)
    }
    return destPath
  }

  const isChinaUser = () => {
    const chinaUserDetector = new TencentUtils.IsInChina()
    const { IsInChina: result } = chinaUserDetector.inChina()
    return result
  }

  const loginWithTencent = async () => {
    let isLoggedIn = false
    if (process.env.TENCENT_SECRET_ID && process.env.TENCENT_SECRET_KEY) {
      try {
        await getOrgId()
        isLoggedIn = true
      } catch (e) {
        if (e.code === 'AuthFailure.TokenFailure') {
          // token expired, re-login
          isLoggedIn = false
        } else {
          throw e
        }
      }
    }
    if (!isLoggedIn) {
      const tencentAuth = new TencentAuth()
      const credentials = await tencentAuth.login()
      if (!credentials) {
        throw new Error('failed to log into Tencent cloud')
      }
      return [true, credentials]
    }
    return [false, null]
  }

  const getOrgId = async () => {
    const userInfoGetter = new TencentCAM.GetUserInformation()
    const { AppId: orgId } = await userInfoGetter.getUserInformation({
      SecretId: process.env.TENCENT_SECRET_ID,
      SecretKey: process.env.TENCENT_SECRET_KEY,
      token: process.env.TENCENT_TOKEN
    })
    return String(orgId)
  }

  let tencentDebug = {}
  const getTencentDebug = (functionName, region) => {
    const key = `${functionName}-${region}`
    if (!tencentDebug[key]) {
      tencentDebug[key] = new TencentDebug(
        {
          SecretId: process.env.TENCENT_SECRET_ID,
          SecretKey: process.env.TENCENT_SECRET_KEY,
          token: process.env.TENCENT_TOKEN
        },
        { functionName },
        region
      )
    }
    return tencentDebug[key]
  }

  const startTencentRemoteLogAndDebug = async (functionName, region, cliCallback) => {
    return await getTencentDebug(functionName, region).remoteDebug(cliCallback)
  }

  const stopTencentRemoteLogAndDebug = async (functionName, region, cliCallback) => {
    return await getTencentDebug(functionName, region).stop(cliCallback)
  }

  const buildTempAccessKeyForTencent = (credentials) => {
    if (credentials.Token) {
      return `${credentials.SecretId}-${credentials.SecretKey}-${credentials.Token}`
    } else {
      return `${credentials.SecretId}-${credentials.SecretKey}`
    }
  }

  const parseCredentialFromTempAccessKey = (key) => {
    const parts = key.split('-')
    if (parts.length >= 2) {
      return {
        SecretId: parts[0],
        SecretKey: parts[1],
        Token: parts[2]
      }
    }
    return {}
  }

  // Add to utils object
  utils.getAgent = getAgent
  utils.getDirSize = getDirSize
  utils.zip = zip
  utils.unzip = unzip
  utils.isChinaUser = isChinaUser
  utils.loginWithTencent = loginWithTencent
  utils.getOrgId = getOrgId
  utils.startTencentRemoteLogAndDebug = startTencentRemoteLogAndDebug
  utils.stopTencentRemoteLogAndDebug = stopTencentRemoteLogAndDebug
  utils.buildTempAccessKeyForTencent = buildTempAccessKeyForTencent
  utils.parseCredentialFromTempAccessKey = parseCredentialFromTempAccessKey
}

// Export
module.exports = utils
