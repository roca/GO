/**
 * Connection
 */

const WS = require('isomorphic-ws')
const utils = require('./utils')

class Connection {
  constructor(sdk) {
    this.sdk = sdk
    this.connection = null
    this.context = {}
  }

  isConnected() {
    return this.connection ? true : false
  }

  /**
   * Connects to websockets and returns the connection with event handlers .on('open', 'message', 'error')
   */
  async connect(options) {
    const self = this

    if (options.orgName) {this.sdk.context.orgName = options.orgName}
    if (options.orgUid) {this.sdk.context.orgUid = options.orgUid}

    // Validate org
    if (!this.sdk.context.orgName && !this.sdk.context.orgUid) {
      throw new Error(`You must specify an "orgName" or "orgUid" to connect`)
    }

    // Sanitize filter
    options.filter = options.filter || {}
    options.filter.stageName = options.filter.stageName ? options.filter.stageName.trim() : null
    options.filter.appName = options.filter.appName ? options.filter.appName.trim() : null
    options.filter.instanceName = options.filter.instanceName
      ? options.filter.instanceName.trim()
      : null

    // Add data to a query param
    let queryParams = '?'
    queryParams = queryParams + `accessKey=${this.sdk.accessKey}&`
    if (this.sdk.context.orgName) {queryParams = queryParams + `orgName=${this.sdk.context.orgName}&`}
    if (this.sdk.context.orgUid) {queryParams = queryParams + `orgUid=${this.sdk.context.orgUid}&`}
    queryParams = queryParams + `filter=${encodeURIComponent(JSON.stringify(options.filter))}&`

    // Set domain
    const domain = this.sdk.getDomain('events-streaming') + queryParams

    // Instantiate websockets library
    this.connection = new WS(domain)

    // Handle message event
    if (options.onEvent) {
      this.connection.onmessage = (message) => {
        message = message && message.data ? message.data : null
        if (typeof message === 'string') {
          message = JSON.parse(message)
        }
        return options.onEvent(message)
      }
    }

    // Handle disconnect event
    if (options.onDisconnect) {
      this.connection.onclose = (message) => {
        message = message && message.data ? message.data : null
        if (typeof message === 'string') {
          message = JSON.parse(message)
        }
        return options.onDisconnect(message)
      }
    }

    return new Promise((resolve, reject) => {
      // Error handler for errors that don't have an unexpected response
      self.connection.onerror = (error) => {
        return reject(`Unexpected Serverless Platform Streaming Error: ${error.message}`)
      }

      self.connection.onopen = () => {
        return resolve()
      }
    })
  }

  /**
   * Terminates the websockets connection
   */
  disconnect() {
    if (this.connection) {
      this.connection.close()
      this.connection = null
    }
  }

  /**
   * Sends a message via the websockets connection.  Validation should be handled in sdk.publish()
   */
  send(event) {
    // Validate
    if (!event) {
      throw new Error(`An "event" is required`)
    }
    if (typeof event !== 'object') {
      throw new Error(`The "event" argument must be an object`)
    }
    if (!event.event || typeof event.event !== 'string') {
      throw new Error(
        `The "event" property containing the event type is required and must be a string`
      )
    }
    if (!event.event || typeof event.event !== 'string') {
      throw new Error(
        `The "event" property containing the event type is required and must be a string`
      )
    }

    // Convert to a safe Serverless Platform Event
    const safeEvent = {}
    safeEvent.accessKey = this.sdk.accessKey
    safeEvent.event = event.event.trim()
    safeEvent.orgUid = event.orgUid || this.sdk.context.orgUid
    safeEvent.orgName = event.orgName || this.sdk.context.orgName
    safeEvent.stageName = this.sdk.context.stageName
    safeEvent.appName = this.sdk.context.appName
    safeEvent.instanceName = this.sdk.context.instanceName
    safeEvent.componentName = this.sdk.context.componentName
    safeEvent.componentVersion = this.sdk.context.componentVersion
    safeEvent.data = event.data || {}

    // Store createdAt date
    safeEvent.data.createdAt = Date.now()

    // Validate
    if (!safeEvent.orgName && !safeEvent.orgUid) {
      throw new Error(`event must have an "orgName" or "orgUid"`)
    }

    this.connection.send(JSON.stringify(safeEvent))
  }

  /**
   * Publish an event synchornously, via the HTTP API
   * @param {*} sdk
   * @param {*} event
   */
  static async publishSync(sdk, event) {
    // Validate
    if (!event) {
      throw new Error(`An "event" is required`)
    }
    if (typeof event !== 'object') {
      throw new Error(`The "event" argument must be an object`)
    }
    if (!event.event || typeof event.event !== 'string') {
      throw new Error(
        `The "event" property containing the event type is required and must be a string`
      )
    }

    // Convert to a safe Serverless Platform Event
    const safeEvent = {}
    safeEvent.accessKey = sdk.accessKey
    safeEvent.event = event.event.trim()
    safeEvent.orgUid = event.orgUid || sdk.context.orgUid
    safeEvent.orgName = event.orgName || sdk.context.orgName
    safeEvent.stageName = sdk.context.stageName
    safeEvent.appName = sdk.context.appName
    safeEvent.instanceName = sdk.context.instanceName
    safeEvent.componentName = sdk.context.componentName
    safeEvent.componentVersion = sdk.context.componentVersion
    safeEvent.data = event.data || {}

    // Validate
    if (!safeEvent.orgName && !safeEvent.orgUid) {
      throw new Error(`event must have an "orgName" or "orgUid"`)
    }

    // Send request
    return await utils.request({
      endpoint: `${sdk.getDomain('events')}/publish`,
      accessKey: sdk.accessKey,
      method: 'POST',
      data: safeEvent
    })
  }
}

module.exports = Connection
